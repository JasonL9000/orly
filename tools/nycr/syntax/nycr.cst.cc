/* <tools/nycr/syntax/nycr.cst.cc>

   This file was generated by nycr. */

#include <tools/nycr/syntax/nycr.cst.h>

#include <cstdio>

#include <base/no_copy_semantics.h>
#include <base/thrower.h>
#include <tools/nycr/error.h>
#include <tools/nycr/test.h>
#include <tools/nycr/syntax/nycr.bison.h>
#include <tools/nycr/syntax/nycr.flex.h>

#include <iostream>
extern FILE *tools_nycr_syntax__in;
extern void tools_nycr_syntax__parse();

extern void tools_nycr_syntax__NycrPrepStr(const char *str);
extern void tools_nycr_syntax__NycrCleanStr();
using namespace std;
using namespace Tools::Nycr::Syntax;
TNycr *Nycr_ = 0;

TNycr *TNycr::ParseFile(const char *path) {
  tools_nycr_syntax__in = fopen(path, "r");
  if (!tools_nycr_syntax__in) {
    THROW << "could not open \"" << path << '\"';
  }
  Nycr_ = 0;
  ::Tools::Nycr::TError::DeleteEach();
  tools_nycr_syntax__parse();
  return Nycr_;
}

TNycr *TNycr::ParseStr(const char *str) {
  Nycr_ = 0;
  ::Tools::Nycr::TError::DeleteEach();
  tools_nycr_syntax__NycrPrepStr(str);
  tools_nycr_syntax__parse();
  tools_nycr_syntax__NycrCleanStr();
  return Nycr_;
}

TNycr::~TNycr() {
  assert(this);
  delete OptDeclSeq;
}

void TNycr::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Nycr" << endl;
  ++depth;
  OptDeclSeq->Write(strm, depth, "OptDeclSeq");
}

bool TNycr::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Nycr" != that->GetName()) {
    cout << "Nycr != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    OptDeclSeq->Test(Child0, "OptDeclSeq");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptDeclSeq here" << endl;
    return false;
  }
  return true;
}

void TNoDeclSeq::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "NoDeclSeq" << endl;
}

bool TNoDeclSeq::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("NoDeclSeq" != that->GetName()) {
    cout << "NoDeclSeq != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TDeclSeq::~TDeclSeq() {
  assert(this);
  delete Decl;
  delete OptDeclSeq;
}

void TDeclSeq::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "DeclSeq" << endl;
  ++depth;
  Decl->Write(strm, depth, "Decl");
  OptDeclSeq->Write(strm, depth, "OptDeclSeq");
}

bool TDeclSeq::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("DeclSeq" != that->GetName()) {
    cout << "DeclSeq != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Decl->Test(Child0, "Decl");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Decl here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    OptDeclSeq->Test(Child1, "OptDeclSeq");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptDeclSeq here" << endl;
    return false;
  }
  return true;
}

TPrecLevel::~TPrecLevel() {
  assert(this);
  delete PrecKwd;
  delete Name;
  delete Semi;
}

void TPrecLevel::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "PrecLevel" << endl;
  ++depth;
  PrecKwd->Write(strm, depth, "PrecKwd");
  Name->Write(strm, depth, "Name");
  Semi->Write(strm, depth, "Semi");
}

bool TPrecLevel::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("PrecLevel" != that->GetName()) {
    cout << "PrecLevel != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    PrecKwd->Test(Child0, "PrecKwd");
  } else {
    cout << "Missing Child: The concrete syntax tree has a PrecKwd here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    Name->Test(Child1, "Name");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Name here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child2 = Child1->TryGetNextSibling();
  if (Child2) {
    Semi->Test(Child2, "Semi");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Semi here" << endl;
    return false;
  }
  return true;
}

void TPrecKwd::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "PrecKwd" << ' ' << Lexeme << endl;
}

bool TPrecKwd::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("PrecKwd" != that->GetName()) {
    cout << "PrecKwd != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TName::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Name" << ' ' << Lexeme << endl;
}

bool TName::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Name" != that->GetName()) {
    cout << "Name != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TSemi::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Semi" << ' ' << Lexeme << endl;
}

bool TSemi::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Semi" != that->GetName()) {
    cout << "Semi != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TBase::~TBase() {
  assert(this);
  delete Name;
  delete OptSuper;
  delete Semi;
}

void TBase::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Base" << endl;
  ++depth;
  Name->Write(strm, depth, "Name");
  OptSuper->Write(strm, depth, "OptSuper");
  Semi->Write(strm, depth, "Semi");
}

bool TBase::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Base" != that->GetName()) {
    cout << "Base != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Name->Test(Child0, "Name");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Name here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    OptSuper->Test(Child1, "OptSuper");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptSuper here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child2 = Child1->TryGetNextSibling();
  if (Child2) {
    Semi->Test(Child2, "Semi");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Semi here" << endl;
    return false;
  }
  return true;
}

TSuper::~TSuper() {
  assert(this);
  delete Colon;
  delete Name;
}

void TSuper::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Super" << endl;
  ++depth;
  Colon->Write(strm, depth, "Colon");
  Name->Write(strm, depth, "Name");
}

bool TSuper::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Super" != that->GetName()) {
    cout << "Super != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Colon->Test(Child0, "Colon");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Colon here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    Name->Test(Child1, "Name");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Name here" << endl;
    return false;
  }
  return true;
}

void TColon::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Colon" << ' ' << Lexeme << endl;
}

bool TColon::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Colon" != that->GetName()) {
    cout << "Colon != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TNoSuper::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "NoSuper" << endl;
}

bool TNoSuper::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("NoSuper" != that->GetName()) {
    cout << "NoSuper != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TRule::~TRule() {
  assert(this);
  delete Name;
  delete OptSuper;
  delete OptRhs;
  delete Semi;
}

void TRule::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Rule" << endl;
  ++depth;
  Name->Write(strm, depth, "Name");
  OptSuper->Write(strm, depth, "OptSuper");
  OptRhs->Write(strm, depth, "OptRhs");
  Semi->Write(strm, depth, "Semi");
}

bool TRule::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Rule" != that->GetName()) {
    cout << "Rule != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Name->Test(Child0, "Name");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Name here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    OptSuper->Test(Child1, "OptSuper");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptSuper here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child2 = Child1->TryGetNextSibling();
  if (Child2) {
    OptRhs->Test(Child2, "OptRhs");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptRhs here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child3 = Child2->TryGetNextSibling();
  if (Child3) {
    Semi->Test(Child3, "Semi");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Semi here" << endl;
    return false;
  }
  return true;
}

TRhs::~TRhs() {
  assert(this);
  delete Arrow;
  delete MemberSeq;
  delete OptOperRef;
}

void TRhs::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Rhs" << endl;
  ++depth;
  Arrow->Write(strm, depth, "Arrow");
  MemberSeq->Write(strm, depth, "MemberSeq");
  OptOperRef->Write(strm, depth, "OptOperRef");
}

bool TRhs::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Rhs" != that->GetName()) {
    cout << "Rhs != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Arrow->Test(Child0, "Arrow");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Arrow here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    MemberSeq->Test(Child1, "MemberSeq");
  } else {
    cout << "Missing Child: The concrete syntax tree has a MemberSeq here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child2 = Child1->TryGetNextSibling();
  if (Child2) {
    OptOperRef->Test(Child2, "OptOperRef");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptOperRef here" << endl;
    return false;
  }
  return true;
}

void TArrow::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Arrow" << ' ' << Lexeme << endl;
}

bool TArrow::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Arrow" != that->GetName()) {
    cout << "Arrow != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TNoMemberSeq::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "NoMemberSeq" << endl;
}

bool TNoMemberSeq::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("NoMemberSeq" != that->GetName()) {
    cout << "NoMemberSeq != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TMemberSeq::~TMemberSeq() {
  assert(this);
  delete Member;
  delete OptMemberSeq;
}

void TMemberSeq::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "MemberSeq" << endl;
  ++depth;
  Member->Write(strm, depth, "Member");
  OptMemberSeq->Write(strm, depth, "OptMemberSeq");
}

bool TMemberSeq::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("MemberSeq" != that->GetName()) {
    cout << "MemberSeq != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Member->Test(Child0, "Member");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Member here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    OptMemberSeq->Test(Child1, "OptMemberSeq");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptMemberSeq here" << endl;
    return false;
  }
  return true;
}

TAnonymousMember::~TAnonymousMember() {
  assert(this);
  delete Name;
}

void TAnonymousMember::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "AnonymousMember" << endl;
  ++depth;
  Name->Write(strm, depth, "Name");
}

bool TAnonymousMember::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("AnonymousMember" != that->GetName()) {
    cout << "AnonymousMember != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Name->Test(Child0, "Name");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Name here" << endl;
    return false;
  }
  return true;
}

TErrorMember::~TErrorMember() {
  assert(this);
  delete ErrorKwd;
}

void TErrorMember::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "ErrorMember" << endl;
  ++depth;
  ErrorKwd->Write(strm, depth, "ErrorKwd");
}

bool TErrorMember::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("ErrorMember" != that->GetName()) {
    cout << "ErrorMember != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    ErrorKwd->Test(Child0, "ErrorKwd");
  } else {
    cout << "Missing Child: The concrete syntax tree has a ErrorKwd here" << endl;
    return false;
  }
  return true;
}

void TErrorKwd::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "ErrorKwd" << ' ' << Lexeme << endl;
}

bool TErrorKwd::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("ErrorKwd" != that->GetName()) {
    cout << "ErrorKwd != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TNamedMember::~TNamedMember() {
  assert(this);
  delete Name;
  delete Colon;
  delete Kind;
}

void TNamedMember::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "NamedMember" << endl;
  ++depth;
  Name->Write(strm, depth, "Name");
  Colon->Write(strm, depth, "Colon");
  Kind->Write(strm, depth, "Kind");
}

bool TNamedMember::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("NamedMember" != that->GetName()) {
    cout << "NamedMember != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Name->Test(Child0, "Name");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Name here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    Colon->Test(Child1, "Colon");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Colon here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child2 = Child1->TryGetNextSibling();
  if (Child2) {
    Kind->Test(Child2, "Kind");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Kind here" << endl;
    return false;
  }
  return true;
}

TOperRef::~TOperRef() {
  assert(this);
  delete PrecKwd;
  delete Name;
}

void TOperRef::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "OperRef" << endl;
  ++depth;
  PrecKwd->Write(strm, depth, "PrecKwd");
  Name->Write(strm, depth, "Name");
}

bool TOperRef::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("OperRef" != that->GetName()) {
    cout << "OperRef != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    PrecKwd->Test(Child0, "PrecKwd");
  } else {
    cout << "Missing Child: The concrete syntax tree has a PrecKwd here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    Name->Test(Child1, "Name");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Name here" << endl;
    return false;
  }
  return true;
}

void TNoOperRef::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "NoOperRef" << endl;
}

bool TNoOperRef::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("NoOperRef" != that->GetName()) {
    cout << "NoOperRef != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TNoRhs::~TNoRhs() {
  assert(this);
  delete Arrow;
  delete EmptyKwd;
}

void TNoRhs::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "NoRhs" << endl;
  ++depth;
  Arrow->Write(strm, depth, "Arrow");
  EmptyKwd->Write(strm, depth, "EmptyKwd");
}

bool TNoRhs::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("NoRhs" != that->GetName()) {
    cout << "NoRhs != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Arrow->Test(Child0, "Arrow");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Arrow here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    EmptyKwd->Test(Child1, "EmptyKwd");
  } else {
    cout << "Missing Child: The concrete syntax tree has a EmptyKwd here" << endl;
    return false;
  }
  return true;
}

void TEmptyKwd::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "EmptyKwd" << ' ' << Lexeme << endl;
}

bool TEmptyKwd::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("EmptyKwd" != that->GetName()) {
    cout << "EmptyKwd != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TLanguage::~TLanguage() {
  assert(this);
  delete Name;
  delete OptSuper;
  delete OptRhs;
  delete OpenAngle;
  delete OptPath;
  delete CloseAngle;
  delete OptExpectedSr;
  delete OptExpectedRr;
  delete Semi;
}

void TLanguage::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Language" << endl;
  ++depth;
  Name->Write(strm, depth, "Name");
  OptSuper->Write(strm, depth, "OptSuper");
  OptRhs->Write(strm, depth, "OptRhs");
  OpenAngle->Write(strm, depth, "OpenAngle");
  OptPath->Write(strm, depth, "OptPath");
  CloseAngle->Write(strm, depth, "CloseAngle");
  OptExpectedSr->Write(strm, depth, "OptExpectedSr");
  OptExpectedRr->Write(strm, depth, "OptExpectedRr");
  Semi->Write(strm, depth, "Semi");
}

bool TLanguage::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Language" != that->GetName()) {
    cout << "Language != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Name->Test(Child0, "Name");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Name here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    OptSuper->Test(Child1, "OptSuper");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptSuper here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child2 = Child1->TryGetNextSibling();
  if (Child2) {
    OptRhs->Test(Child2, "OptRhs");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptRhs here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child3 = Child2->TryGetNextSibling();
  if (Child3) {
    OpenAngle->Test(Child3, "OpenAngle");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OpenAngle here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child4 = Child3->TryGetNextSibling();
  if (Child4) {
    OptPath->Test(Child4, "OptPath");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptPath here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child5 = Child4->TryGetNextSibling();
  if (Child5) {
    CloseAngle->Test(Child5, "CloseAngle");
  } else {
    cout << "Missing Child: The concrete syntax tree has a CloseAngle here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child6 = Child5->TryGetNextSibling();
  if (Child6) {
    OptExpectedSr->Test(Child6, "OptExpectedSr");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptExpectedSr here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child7 = Child6->TryGetNextSibling();
  if (Child7) {
    OptExpectedRr->Test(Child7, "OptExpectedRr");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptExpectedRr here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child8 = Child7->TryGetNextSibling();
  if (Child8) {
    Semi->Test(Child8, "Semi");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Semi here" << endl;
    return false;
  }
  return true;
}

void TOpenAngle::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "OpenAngle" << ' ' << Lexeme << endl;
}

bool TOpenAngle::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("OpenAngle" != that->GetName()) {
    cout << "OpenAngle != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TPath::~TPath() {
  assert(this);
  delete Name;
  delete OptPathTail;
}

void TPath::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Path" << endl;
  ++depth;
  Name->Write(strm, depth, "Name");
  OptPathTail->Write(strm, depth, "OptPathTail");
}

bool TPath::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Path" != that->GetName()) {
    cout << "Path != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Name->Test(Child0, "Name");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Name here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    OptPathTail->Test(Child1, "OptPathTail");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptPathTail here" << endl;
    return false;
  }
  return true;
}

void TNoPathTail::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "NoPathTail" << endl;
}

bool TNoPathTail::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("NoPathTail" != that->GetName()) {
    cout << "NoPathTail != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TPathTail::~TPathTail() {
  assert(this);
  delete Slash;
  delete Path;
}

void TPathTail::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "PathTail" << endl;
  ++depth;
  Slash->Write(strm, depth, "Slash");
  Path->Write(strm, depth, "Path");
}

bool TPathTail::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("PathTail" != that->GetName()) {
    cout << "PathTail != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Slash->Test(Child0, "Slash");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Slash here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    Path->Test(Child1, "Path");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Path here" << endl;
    return false;
  }
  return true;
}

void TSlash::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Slash" << ' ' << Lexeme << endl;
}

bool TSlash::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Slash" != that->GetName()) {
    cout << "Slash != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TNoPath::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "NoPath" << endl;
}

bool TNoPath::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("NoPath" != that->GetName()) {
    cout << "NoPath != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TCloseAngle::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "CloseAngle" << ' ' << Lexeme << endl;
}

bool TCloseAngle::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("CloseAngle" != that->GetName()) {
    cout << "CloseAngle != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TNoExpectedSr::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "NoExpectedSr" << endl;
}

bool TNoExpectedSr::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("NoExpectedSr" != that->GetName()) {
    cout << "NoExpectedSr != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TExpectedSr::~TExpectedSr() {
  assert(this);
  delete SrKwd;
  delete IntLiteral;
}

void TExpectedSr::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "ExpectedSr" << endl;
  ++depth;
  SrKwd->Write(strm, depth, "SrKwd");
  IntLiteral->Write(strm, depth, "IntLiteral");
}

bool TExpectedSr::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("ExpectedSr" != that->GetName()) {
    cout << "ExpectedSr != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    SrKwd->Test(Child0, "SrKwd");
  } else {
    cout << "Missing Child: The concrete syntax tree has a SrKwd here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    IntLiteral->Test(Child1, "IntLiteral");
  } else {
    cout << "Missing Child: The concrete syntax tree has a IntLiteral here" << endl;
    return false;
  }
  return true;
}

void TSrKwd::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "SrKwd" << ' ' << Lexeme << endl;
}

bool TSrKwd::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("SrKwd" != that->GetName()) {
    cout << "SrKwd != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TIntLiteral::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "IntLiteral" << ' ' << Lexeme << endl;
}

bool TIntLiteral::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("IntLiteral" != that->GetName()) {
    cout << "IntLiteral != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TNoExpectedRr::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "NoExpectedRr" << endl;
}

bool TNoExpectedRr::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("NoExpectedRr" != that->GetName()) {
    cout << "NoExpectedRr != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TExpectedRr::~TExpectedRr() {
  assert(this);
  delete RrKwd;
  delete IntLiteral;
}

void TExpectedRr::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "ExpectedRr" << endl;
  ++depth;
  RrKwd->Write(strm, depth, "RrKwd");
  IntLiteral->Write(strm, depth, "IntLiteral");
}

bool TExpectedRr::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("ExpectedRr" != that->GetName()) {
    cout << "ExpectedRr != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    RrKwd->Test(Child0, "RrKwd");
  } else {
    cout << "Missing Child: The concrete syntax tree has a RrKwd here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    IntLiteral->Test(Child1, "IntLiteral");
  } else {
    cout << "Missing Child: The concrete syntax tree has a IntLiteral here" << endl;
    return false;
  }
  return true;
}

void TRrKwd::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "RrKwd" << ' ' << Lexeme << endl;
}

bool TRrKwd::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("RrKwd" != that->GetName()) {
    cout << "RrKwd != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TOper::~TOper() {
  assert(this);
  delete Name;
  delete OptSuper;
  delete Pattern;
  delete PrecLevelRef;
  delete Assoc;
  delete Semi;
}

void TOper::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Oper" << endl;
  ++depth;
  Name->Write(strm, depth, "Name");
  OptSuper->Write(strm, depth, "OptSuper");
  Pattern->Write(strm, depth, "Pattern");
  PrecLevelRef->Write(strm, depth, "PrecLevelRef");
  Assoc->Write(strm, depth, "Assoc");
  Semi->Write(strm, depth, "Semi");
}

bool TOper::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Oper" != that->GetName()) {
    cout << "Oper != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Name->Test(Child0, "Name");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Name here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    OptSuper->Test(Child1, "OptSuper");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptSuper here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child2 = Child1->TryGetNextSibling();
  if (Child2) {
    Pattern->Test(Child2, "Pattern");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Pattern here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child3 = Child2->TryGetNextSibling();
  if (Child3) {
    PrecLevelRef->Test(Child3, "PrecLevelRef");
  } else {
    cout << "Missing Child: The concrete syntax tree has a PrecLevelRef here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child4 = Child3->TryGetNextSibling();
  if (Child4) {
    Assoc->Test(Child4, "Assoc");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Assoc here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child5 = Child4->TryGetNextSibling();
  if (Child5) {
    Semi->Test(Child5, "Semi");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Semi here" << endl;
    return false;
  }
  return true;
}

TPattern::~TPattern() {
  assert(this);
  delete Eq;
  delete StrLiteral;
  delete OptPriLevel;
}

void TPattern::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Pattern" << endl;
  ++depth;
  Eq->Write(strm, depth, "Eq");
  StrLiteral->Write(strm, depth, "StrLiteral");
  OptPriLevel->Write(strm, depth, "OptPriLevel");
}

bool TPattern::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Pattern" != that->GetName()) {
    cout << "Pattern != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Eq->Test(Child0, "Eq");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Eq here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    StrLiteral->Test(Child1, "StrLiteral");
  } else {
    cout << "Missing Child: The concrete syntax tree has a StrLiteral here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child2 = Child1->TryGetNextSibling();
  if (Child2) {
    OptPriLevel->Test(Child2, "OptPriLevel");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptPriLevel here" << endl;
    return false;
  }
  return true;
}

void TEq::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Eq" << ' ' << Lexeme << endl;
}

bool TEq::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Eq" != that->GetName()) {
    cout << "Eq != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TSingleQuotedRawStrLiteral::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "SingleQuotedRawStrLiteral" << ' ' << Lexeme << endl;
}

bool TSingleQuotedRawStrLiteral::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("SingleQuotedRawStrLiteral" != that->GetName()) {
    cout << "SingleQuotedRawStrLiteral != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TDoubleQuotedStrLiteral::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "DoubleQuotedStrLiteral" << ' ' << Lexeme << endl;
}

bool TDoubleQuotedStrLiteral::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("DoubleQuotedStrLiteral" != that->GetName()) {
    cout << "DoubleQuotedStrLiteral != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TSingleQuotedStrLiteral::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "SingleQuotedStrLiteral" << ' ' << Lexeme << endl;
}

bool TSingleQuotedStrLiteral::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("SingleQuotedStrLiteral" != that->GetName()) {
    cout << "SingleQuotedStrLiteral != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TDoubleQuotedRawStrLiteral::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "DoubleQuotedRawStrLiteral" << ' ' << Lexeme << endl;
}

bool TDoubleQuotedRawStrLiteral::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("DoubleQuotedRawStrLiteral" != that->GetName()) {
    cout << "DoubleQuotedRawStrLiteral != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TPriLevel::~TPriLevel() {
  assert(this);
  delete PriKwd;
  delete IntLiteral;
}

void TPriLevel::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "PriLevel" << endl;
  ++depth;
  PriKwd->Write(strm, depth, "PriKwd");
  IntLiteral->Write(strm, depth, "IntLiteral");
}

bool TPriLevel::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("PriLevel" != that->GetName()) {
    cout << "PriLevel != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    PriKwd->Test(Child0, "PriKwd");
  } else {
    cout << "Missing Child: The concrete syntax tree has a PriKwd here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    IntLiteral->Test(Child1, "IntLiteral");
  } else {
    cout << "Missing Child: The concrete syntax tree has a IntLiteral here" << endl;
    return false;
  }
  return true;
}

void TPriKwd::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "PriKwd" << ' ' << Lexeme << endl;
}

bool TPriKwd::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("PriKwd" != that->GetName()) {
    cout << "PriKwd != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TNoPriLevel::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "NoPriLevel" << endl;
}

bool TNoPriLevel::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("NoPriLevel" != that->GetName()) {
    cout << "NoPriLevel != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TNonassocKwd::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "NonassocKwd" << ' ' << Lexeme << endl;
}

bool TNonassocKwd::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("NonassocKwd" != that->GetName()) {
    cout << "NonassocKwd != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TLeftKwd::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "LeftKwd" << ' ' << Lexeme << endl;
}

bool TLeftKwd::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("LeftKwd" != that->GetName()) {
    cout << "LeftKwd != " << that->GetName() << endl;
    return false;
  }
  return true;
}

void TRightKwd::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "RightKwd" << ' ' << Lexeme << endl;
}

bool TRightKwd::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("RightKwd" != that->GetName()) {
    cout << "RightKwd != " << that->GetName() << endl;
    return false;
  }
  return true;
}

TKeyword::~TKeyword() {
  assert(this);
  delete Name;
  delete OptSuper;
  delete Pattern;
  delete Semi;
}

void TKeyword::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "Keyword" << endl;
  ++depth;
  Name->Write(strm, depth, "Name");
  OptSuper->Write(strm, depth, "OptSuper");
  Pattern->Write(strm, depth, "Pattern");
  Semi->Write(strm, depth, "Semi");
}

bool TKeyword::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("Keyword" != that->GetName()) {
    cout << "Keyword != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Name->Test(Child0, "Name");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Name here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child1 = Child0->TryGetNextSibling();
  if (Child1) {
    OptSuper->Test(Child1, "OptSuper");
  } else {
    cout << "Missing Child: The concrete syntax tree has a OptSuper here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child2 = Child1->TryGetNextSibling();
  if (Child2) {
    Pattern->Test(Child2, "Pattern");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Pattern here" << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child3 = Child2->TryGetNextSibling();
  if (Child3) {
    Semi->Test(Child3, "Semi");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Semi here" << endl;
    return false;
  }
  return true;
}

TBadDecl::~TBadDecl() {
  assert(this);
  delete Semi;
}

void TBadDecl::Write(ostream &strm, size_t depth, const char *as_member) const {
  assert(this);
  assert(&strm);
  strm << ::Tools::Nycr::TIndent(depth);
  if (as_member) {
    strm << as_member << " -> ";
  }
  strm << "BadDecl" << endl;
  ++depth;
  Semi->Write(strm, depth, "Semi");
}

bool TBadDecl::Test(::Tools::Nycr::Test::TNode *that, const char *as_member) const {
  assert(this);
  if (as_member && as_member != that->GetKind()) {
    cout << as_member << " != " << that->GetKind() << endl;
    return false;
  }
  if ("BadDecl" != that->GetName()) {
    cout << "BadDecl != " << that->GetName() << endl;
    return false;
  }
  ::Tools::Nycr::Test::TNode *Child0 = that->TryGetFirstChild();
  if (Child0) {
    Semi->Test(Child0, "Semi");
  } else {
    cout << "Missing Child: The concrete syntax tree has a Semi here" << endl;
    return false;
  }
  return true;
}
